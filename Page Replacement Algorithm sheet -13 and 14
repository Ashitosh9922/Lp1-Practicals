
TE A_B_2024-25
Upcoming
Woohoo, no work due in soon!

Announce something to your class

Announcement: 'SPOS Prelim Paper'
RASHMI MORE
Created 16 Oct16 Oct
SPOS Prelim Paper

SPOS Prelim.docx
Word

Add class comment…

Material: 'LPI Index'
Ketaki Bhoyar posted a new material: LPI Index
Created 16 Oct16 Oct
Assignment: "TOC Prelim Question Paper"
Ketaki Bhoyar posted a new assignment: TOC Prelim Question Paper
Created 14 Oct14 Oct

Announcement: 'Oral questions for theory assignment…'
RASHMI MORE
Created 14 Oct14 Oct
Oral questions for theory assignment checking..
5 Questions will be asked during assignment checking.

SPOS Unit3-6_Oral Questions.docx
Word

Add class comment…

Material: 'DBMS Problem Statements'
Akanksha Kulkarni posted a new material: DBMS Problem Statements
Created 14 Oct14 Oct
Material: 'CNS Prelim paper'
Akanksha Kulkarni posted a new material: CNS Prelim paper
Created 14 Oct14 Oct

Announcement: 'SPOS Assignments 5 and 6'
RASHMI MORE
Created 11 Oct11 Oct
SPOS Assignments 5 and 6

spos-assignment-5-2024.pdf
PDF

spos-assignment-6-2024.pdf
PDF

Add class comment…

Material: 'DBMSL MongoDB Assignment Video Tutorials'
Akanksha Kulkarni posted a new material: DBMSL MongoDB Assignment Video Tutorials
Created 11 Oct11 Oct
Material: 'DBMS Prelim Question Paper'
Akanksha Kulkarni posted a new material: DBMS Prelim Question Paper
Created 11 Oct11 Oct

Announcement: 'LP I Practical No. 7'
RASHMI MORE
Created 9 Oct9 Oct
LP I Practical No. 7

PageReplacement (2).java
Java

Add class comment…

Material: 'DBMS Previous Year Question Papers'
Akanksha Kulkarni posted a new material: DBMS Previous Year Question Papers
Created 9 Oct9 Oct (Edited 9 Oct)
Material: 'DBMS Unit 6 Material'
Akanksha Kulkarni posted a new material: DBMS Unit 6 Material
Created 9 Oct9 Oct
Material: 'DBMS Unit 5 Material'
Akanksha Kulkarni posted a new material: DBMS Unit 5 Material
Created 9 Oct9 Oct
Material: 'DBMS Unit 4 Material'
Akanksha Kulkarni posted a new material: DBMS Unit 4 Material
Created 9 Oct9 Oct
Material: 'DBMS Unit 3 Material'
Akanksha Kulkarni posted a new material: DBMS Unit 3 Material
Created 9 Oct9 Oct
Material: 'DBMS Lab Connectivity Program (JDBC and MongoDB)'
Akanksha Kulkarni posted a new material: DBMS Lab Connectivity Program (JDBC and MongoDB)
Created 9 Oct9 Oct
Material: 'DBMS Assignment 3, 4, 5 ,6 '
Akanksha Kulkarni posted a new material: DBMS Assignment 3, 4, 5 ,6
Created 9 Oct9 Oct (Edited 11 Oct)
Assignment: "TOC - Assignment 4,5,6"
Ketaki Bhoyar posted a new assignment: TOC - Assignment 4,5,6
Created 8 Oct8 Oct
Assignment: "TOC Assignment 3"
Ketaki Bhoyar posted a new assignment: TOC Assignment 3
Created 8 Oct8 Oct
Material: 'LPI - Macro Pass Two'
Ketaki Bhoyar posted a new material: LPI - Macro Pass Two
Created 8 Oct8 Oct
package D;

//Java implementation of above algorithm

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.ArrayList;

public class PageReplacement
{
	static int pageFrames=0;
	 //Least Recently Used(LRU) Page Replacement Algorithm
	 static int lru(int referenceString[])
	 {
		 //This array list will contain all the pages that are currently in memory
	     ArrayList<Integer>  pages = new ArrayList<Integer>(pageFrames);
	   
	     // This hashmap will store least recently used indexes of the pages
	     HashMap<Integer, Integer> indexes = new HashMap<>();
	   
	     // Start from initial page
	     int page_faults = 0,  n = referenceString.length, curPage;
	     for (int i=0; i<n; i++)
	     {
	         curPage = referenceString[i];
	    	 // Check if the set can hold more pages
	         if (pages.size() < pageFrames)
	         {
	             // Insert it into set if not already present
	             // This represents a page fault
	             if (!pages.contains(curPage))
	             {
	                 pages.add(curPage);
	   
	                 // increment page fault count
	                 page_faults++;
	                 displayPageFrames(pages, page_faults);
	             }
	   
	             // Store the recently used index of each page
	             indexes.put(curPage, i);
	         }
	   
	         // If the set is full then need to select a page to be replaced
	         // The page that is selected for replacement is the least recently used page
	         else
	         {
	             // Check if current page is not already present in the set
	             if (!pages.contains(curPage))
	             {
	                 // The page having the lowest value of associated index will be the least recently used page
	                 int lru = Integer.MAX_VALUE, pageToBeReplaced =0;
	                 int temp;
	                 for(int j = 0; j < pages.size(); j++){
	                	 temp = pages.get(j);
	                	 if (indexes.get(temp) < lru)
	                     {
	                         lru = indexes.get(temp);
	                         pageToBeReplaced = j;
	                     }
	                 }
	              
	                 indexes.remove(pages.get(pageToBeReplaced));
	                 pages.set(pageToBeReplaced, curPage);
	                 // Increment page fault count
	                 page_faults++;
	                 displayPageFrames(pages, page_faults);
	             }
	   
	             // Update the current page index
	             indexes.put(curPage, i);
	         }
	     }
	     return page_faults;
	 }
  
	//Optimal Page Replacement Algorithm
	 static int optimal(int referenceString[])
	 {
		//This array list will contain all the pages that are currently in memory
	     ArrayList<Integer>  pages = new ArrayList<Integer>(pageFrames);
	   
	     // This hashmap will store least recently used indexes of the pages
	     HashMap<Integer, Integer> indexes = new HashMap<>();
	   
	     // Start from initial page
	     int page_faults = 0, curPage, n = referenceString.length;
	     for (int i=0; i<n; i++)
	     {
	    	 curPage = referenceString[i];
	         // Check if the set can hold more pages
	         if (pages.size() < pageFrames)
	         {
	             // Insert it into set if not already present
	             // This represents a page fault
	             if (!pages.contains(curPage))
	             {
	                 pages.add(curPage);
	   
	                 // increment page fault count
	                 page_faults++;
	                 displayPageFrames(pages, page_faults);
	             }
	   
	             // Store the future index of the page
	             indexes.put(curPage, findNextIndex(curPage,i, referenceString));
	         }
	   
	         // If the set is full then need to select a page to be replaced
	         // The page that is selected for replacement is the one that will not be used for the longest period of time
	         else
	         {
	             // Check if current page is not already present in the set
	             if (!pages.contains(curPage))
	             {
	                 // Find a page that is referenced farthest in the future
	            	 //This is implemented by finding a page that has greatest index value
	            	 int optimal = Integer.MIN_VALUE, pageToBeReplaced =0;;
	                 int temp;
	                 for(int j = 0; j < pages.size(); j++){
	                	 temp = pages.get(j);
	                	 if (indexes.get(temp) > optimal)
	                     {
	                		 optimal = indexes.get(temp);
	                         pageToBeReplaced = j;
	                     }
	                 }
	              
	                 indexes.remove(pages.get(pageToBeReplaced));
	                 pages.set(pageToBeReplaced, curPage);
	              
	                 // Increment page faults
	                 page_faults++;
	                 displayPageFrames(pages, page_faults);
	             }
	   
	             // Update the current page index
	             indexes.put(curPage, findNextIndex(curPage,i, referenceString));
	         }
	     }
	     return page_faults;
	 }
	 
	 static int findNextIndex(int curPage, int curIndex, int pages[]){
		 //Starting at the current index find the index of future use of the page
		 int i;
		 for(i= curIndex+1; i < pages.length; i++){
			 if(pages[i] == curPage){
				 break;
			 }
		 }
		 return i;
	 }
	 
	 static void displayPageFrames(ArrayList<Integer> pages, int page_faults){
         System.out.print("At PageFault- " + page_faults  + " :: Pages- ");
         for(int i = 0; i < pages.size(); i++) {
             System.out.print(" " + pages.get(i));
         }
         System.out.print("\n");
	 }
	 
	 // Driver method
	 public static void main(String args[])
	 {
	     int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2,1,2,0,1,7,0,1};
	     
	     pageFrames = 3;
	     int pageFaults;
	     System.out.println("--- Implementing Least Recently Used Page Replacement Algorithm -----");
	     pageFaults = lru(pages);
	     System.out.println("Number of page faults = " + pageFaults);
	     System.out.print("\n");
	     System.out.println("--- Implementing Optimal Page Replacement Algorithm -----");
	     pageFaults = optimal(pages);
	     System.out.println("Number of page faults = " + pageFaults);
	 }
}
